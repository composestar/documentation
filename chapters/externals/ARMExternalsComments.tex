The advantage of using the Singleton pattern becomes visible when we would use a parameter as initialization expression. 
In the given example \autoref{lst::arm::ext:example1}, we see that we can address the same instance of Score from three filter modules and that there will only be one instance of Score in the application. 
We could do the same without a filter module, by just adding the Score object to every class. 
The advantage of the filter is that when we would write \lstinline[breaklines=false]!score : pacman.Score = ?instance;!, then we only need to change the initialization expression in one spot instead of all the classes where we want to access Score.

\para{The Alternative to Singletons}
With the addition of filter module parameters it is also possible to use a given object from the parameters as an
external. 
This fixes the old limitation that you had to choose between a singleton construction, which results in that every filter module points the same object, or to use an internal, which results in that very instance has it own instance of the internal. 
In \autoref{lst::ARM:ext:example2} we have an example were two selections, selA and selB, get a different instance of the class secretary. 
Using an object as a filter module parameter makes it possible to use an instance for a certain selection of filter module instances instead of all filter module instances.

\para{Arguments in the initialization expression}
The possibility to use arguments in the initialization expression is currently not supported. 
This is because the grammar does not support it and it is not certain whether the other parts can handle them. 

\para{Static Methods}
It is possible to declare an external without an initialization expression.
The purpose of such construct is that with an external declaration without an initialization expression it is possible to introduce static methods. 
A static method from a class can be used without having instantiated an object from this class.
Because the target needs to be an internal, external, or the keyword ``inner'', the only way you are able to substitute the target, so that it is send to a static method, is by declaring the class as an external.
However this functionality is currently not implemented.